import*as t from"three";class e{curve;radius;tilt;constructor(t,e=1,r=0){this.curve=t,this.radius=e,this.tilt=r}computeFrames(e){const r=new t.Vector3,s=new t.Vector3,o=new t.Vector3,i=new t.Vector3,a=new t.Vector3,l=new t.Vector3,n=new t.Vector3,c=new t.Vector3,h=[],u=this.tilt instanceof Function?this.tilt:()=>this.tilt,p=(t,e)=>{h[t]=[],h[t][0]=s.clone(),h[t][1]=o.clone(),h[t][2]=r.clone(),h[t][3]=this.curve.getPointAt(t/e);const i=u(t,e);i&&h[t][0].applyAxisAngle(r,i),i&&h[t][1].applyAxisAngle(r,i)};this.curve.getTangentAt(0,r),c.set(Math.abs(r.x),Math.abs(r.y),Math.abs(r.z)),n.set(1,0,0),c.y<=c.x?c.z<=c.y?n.set(0,0,1):n.set(0,1,0):c.z<=c.x&&n.set(0,0,1),c.crossVectors(r,n).normalize(),s.crossVectors(r,c),o.crossVectors(r,s),p(0,e);for(let t=1,n=NaN;t<=e;++t)n=t/e,this.curve.getTangentAt(n,i),a.copy(s),c.crossVectors(r,i).length()>Number.EPSILON&&a.applyAxisAngle(c.normalize(),Math.acos(Math.max(-1,Math.min(1,r.dot(i))))),l.crossVectors(i,a),r.copy(i),o.copy(l),s.copy(a),p(t,e);return h}}class r extends t.BufferGeometry{constructor(t,e,s){super(),this.#compute(t,r.parseSegments(e),s)}static parseSegments(t){const e=[];return Array.isArray(t)?(e[0]=t[0],e[1]=void 0===t[1]?[t[0]]:t[1],e[2]=t[2]||0):(e[0]=t,e[1]=[t],e[2]=0),e[0]=Math.max(1,0|e[0]),e[1]=e[1].filter((t=>t>=1)).map((t=>0|t)),e[1].length||(e[1]=[e[0]]),e[1].length%2&&e[1].push(...e[1]),e[2]|=0,e}#compute(e,[r,s,o],i){const a=[],l=[],n=[],c=s.flatMap(((t,e)=>Array(t).fill(1-e%2))),h=s.flatMap((t=>Array.from(Array(t).keys()))),u=s.flatMap((t=>Array(t).fill(t))),p=e.computeFrames(r),y=e.radius instanceof Function?e.radius:()=>e.radius,m=new t.Vector3,x=new t.Vector3,f=c.length;for(let t,e,s,g=0,C=0;g<r;){if(t=(o+g)%f,e=t<0?f+t:t,t=u[e]-h[e],s=g+t>r?r-g:t,c[e]){for(let t,o,c,f,d=0;d<=s;++d)[t,,,o]=p[g+d],c=y(g+d,r),m.copy(t).multiplyScalar(c).add(o),x.copy(t).multiplyScalar(-c).add(o),l.push(m.x,m.y,m.z,x.x,x.y,x.z),i&&n.push(...i(d<s?h[e+d]:h[e+d-1]+1,u[e],g+d,r)),d<s&&a.push(f=2*d+C,f+1,f+2,f+2,f+1,f+3);C+=2*(s+1)}g+=s}this.attributes.position=new t.Float32BufferAttribute(l,3),i&&(this.attributes.uv=new t.Float32BufferAttribute(n,2)),this.setIndex(a),this.computeVertexNormals()}}class s extends t.LineSegments{strip;segments;size;xColor;yColor;zColor;constructor(e,r,s=1,o=16711680,i=65280,a=255){super(new t.BufferGeometry,new t.LineBasicMaterial({vertexColors:!0})),this.strip=e,this.segments=r,this.size=s,this.type="StripHelper",this.xColor=new t.Color(o),this.yColor=new t.Color(i),this.zColor=new t.Color(a),this.update()}update(){const e=Math.max(1,0|this.segments),r=Math.max(0,this.size),s=this.strip.computeFrames(e),o=new Float32Array(18*s.length),i=new Float32Array(18*s.length);this.geometry.dispose(),this.geometry.attributes.position=new t.BufferAttribute(o,3),this.geometry.attributes.color=new t.BufferAttribute(i,3);for(const[t,[e,a,l,n]]of s.entries())e.multiplyScalar(r).add(n),a.multiplyScalar(r).add(n),l.multiplyScalar(r).add(n),o.set([n.x,n.y,n.z,e.x,e.y,e.z,n.x,n.y,n.z,a.x,a.y,a.z,n.x,n.y,n.z,l.x,l.y,l.z],18*t),i.set([this.xColor.r,this.xColor.g,this.xColor.b,this.xColor.r,this.xColor.g,this.xColor.b,this.yColor.r,this.yColor.g,this.yColor.b,this.yColor.r,this.yColor.g,this.yColor.b,this.zColor.r,this.zColor.g,this.zColor.b,this.zColor.r,this.zColor.g,this.zColor.b],18*t)}}function o(t,e){switch(e){case 0:return[0,t,1,t];case 1:return[t,1,t,0];case 2:return[1,t,0,t];case 3:return[t,0,t,1]}}class i{static dash=[(t,e)=>o(t/e,0),(t,e)=>o(t/e,1),(t,e)=>o(1-t/e,2),(t,e)=>o(1-t/e,3)];static strip=[(t,e,r,s)=>o(r/s,0),(t,e,r,s)=>o(r/s,1),(t,e,r,s)=>o(1-r/s,2),(t,e,r,s)=>o(1-r/s,3)]}export{e as Strip,r as StripGeometry,s as StripHelper,i as UvPreset};
